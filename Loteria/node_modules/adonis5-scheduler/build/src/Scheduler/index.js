"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../utils");
const Exceptions_1 = require("../Exceptions");
const node_schedule_1 = __importDefault(require("node-schedule"));
/**
 * @module Scheduler
 * @description Task scheduler provider using node-schedule
 */
class Scheduler {
    /**
     */
    constructor(appRootPath, container, logger) {
        this.container = container;
        this.logger = logger;
        this.appRootPath = appRootPath;
        this.registeredTasks = [];
        this._configureTasksPath();
    }
    /**
     * Configure tasks absolute path for app
     * /<project-dir>/app/Tasks
     */
    _configureTasksPath() {
        this.tasksPath = path_1.default.join(this.appRootPath, 'app', 'Tasks');
        this.tasksPath = path_1.default.normalize(this.tasksPath);
    }
    /**
     * Load task file
     */
    async _fetchTask(task) {
        const taskInstance = this.container.make(task, [this.appRootPath + '/tmpLock', this.logger]);
        const taskInstanceConstructor = taskInstance.constructor;
        // Every task must expose a schedule
        if (!('schedule' in taskInstanceConstructor)) {
            throw Exceptions_1.RuntimeException.undefinedTaskSchedule(task.constructor.name);
        }
        // Every task must expose a handle function
        if (!('handle' in taskInstance)) {
            throw Exceptions_1.RuntimeException.undefinedTaskHandle(task.constructor.name);
        }
        // if (!(taskInstance instanceof Task)) {
        // 	throw RuntimeException.undefinedInstanceTask(file)
        // }
        // Track currently registered tasks in memory
        this.registeredTasks.push(taskInstance);
        // Before add task to schedule need check & unlock file if exist
        const locked = await taskInstance.locker.check();
        if (locked) {
            await taskInstance.locker.unlock();
        }
        // Register task handler
        node_schedule_1.default.scheduleJob(taskInstanceConstructor.schedule, taskInstance._run.bind(taskInstance));
    }
    getRegisteredTasks() {
        return this.registeredTasks;
    }
    /**
     * Register scheduled tasks for every task found in app/Tasks
     *
     * @public
     */
    async run(taskClasses = []) {
        utils_1.debug('Scan tasks path %s', this.tasksPath);
        if (taskClasses.length === 0) {
            try {
                const taskFiles = fs_1.default.readdirSync(this.tasksPath);
                for (const file of taskFiles) {
                    const isAllowed = ['.js', '.ts'].includes(path_1.default.extname(file)) && !file.includes('.map');
                    if (isAllowed) {
                        const filePath = path_1.default.join(this.tasksPath, file);
                        let task;
                        try {
                            task = require(filePath).default;
                            await this._fetchTask(task);
                        }
                        catch (e) {
                            if (e instanceof ReferenceError) {
                                utils_1.debug('Unable to import task class <%s>. Is it a valid javascript class?', file);
                                return;
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                }
            }
            catch (e) {
                // If the directory isn't found, log a message and exit gracefully
                if (e.code === 'ENOENT') {
                    throw Exceptions_1.RuntimeException.notFoundTask(this.tasksPath);
                }
                throw e;
            }
        }
        for (let task of taskClasses) {
            await this._fetchTask(task);
        }
        utils_1.debug('scheduler running %d tasks', this.registeredTasks.length);
    }
}
exports.default = Scheduler;
