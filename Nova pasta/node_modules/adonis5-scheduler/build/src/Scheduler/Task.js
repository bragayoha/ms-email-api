"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTask = void 0;
const ms_1 = __importDefault(require("ms"));
const Locker_1 = __importDefault(require("./Locker"));
/**
 * @module BaseTask
 * @description Task base class
 */
class BaseTask {
    constructor(tmpPath, logger) {
        this.tmpPath = tmpPath;
        this.logger = logger;
        this.name = this._getName();
        this.locker = this._getLocker();
    }
    /**
     * Set enable use .lock file for block run retry task
     * Lock file save to `tmpPath`
     */
    static get useLock() {
        return false;
    }
    static get schedule() {
        return '* * * * *';
    }
    /**
     * Example input JasperEventsDrop
     * Example output jasper:events:drop
     */
    _getName() {
        return this.constructor.name
            .replace(/([A-Z])/g, ' $1')
            .split(' ')
            .splice(1)
            .map((str) => str.toLowerCase())
            .join(':');
    }
    _getLocker() {
        return new Locker_1.default(this.name, this.tmpPath);
    }
    async _run() {
        const useLock = this.constructor.useLock;
        if (useLock) {
            const locked = await this.locker.check();
            if (locked) {
                this.logger.warn(`${this.constructor.name}: Lock file exist so current task is running, let's skip`);
                return;
            }
            await this.locker.lock();
        }
        this.startedAt = new Date().getMilliseconds();
        try {
            /**
             * Worker task handle
             */
            await this.handle();
        }
        catch (e) {
            this.logger.error(e);
        }
        if (useLock) {
            await this.locker.unlock();
        }
    }
    async handle() { }
    /**
     * Get task running time duration
     */
    duration(source = false) {
        let duration = new Date().getMilliseconds() - this.startedAt;
        if (source) {
            return duration;
        }
        duration = ms_1.default(duration);
        return duration;
    }
}
exports.BaseTask = BaseTask;
